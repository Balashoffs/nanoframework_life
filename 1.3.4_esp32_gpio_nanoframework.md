# Работа с портами ввода-вывода GPIO из ESP-IDF


Добрый день, уважаемый читатель! В этой статье обсудим методы работы со встроенными портами ввода-вывода GPIO в _цифровом_ режиме.

## Какие выводы GPIO можно использовать для ввод и вывод

Давайте вспомним, какие выводы можно использовать на ESP32 (я буду рассматривать линейки _ESP32-WROOM_ или _ESP32-WROVER_).

Чип ESP32 имеет 34 физических контакта GPIO. Каждая контактная площадка может использоваться как вход/выход общего назначения (_GPIO_) или может быть подключена к внутреннему периферийному сигналу. Мультиплексоры IO\_MUX, RTC IO\_MUX и матрица GPIO отвечают за маршрутизацию сигналов от периферийных устройств к контактам GPIO. Вместе эти системы обеспечивают гибко настраиваемый ввод-вывод.

[![Image 44](/1.3.4/esp32-devkitc-pins.png)](/1.3.4/esp32-devkitc-pins.png) 

Порты ввода-вывода для ESP32-DevKitC V4

*   **На ввод и вывод**_для ESP32-WROOM_ можно смело использовать следующие 18 выводов GPIO: **4, 14, 16, 17, 18, 19, 21, 22, 23, 25, 26, 27, 32, 33**. Все указанные выводы**имеют встроенные программно-подключаемые резисторы подтяжки 45 кОм**(_в документации это называется “слабая подтяжка”_). Я буду называть эти порты “универсальными”, для простоты понимания. Некоторые из них можно назначить для использования различных интерфейсов: I2C, SPI и т.д._Примечания: для ESP32-WROVER выводы 16 и 17 использовать нельзя_.
*   Выводы**GPIO 34, 35, 36, 39**можно использовать**только на ввод**, и у них отсутствуют встроенные резисторы слабой подтяжки. На эти же выводы выведен канал ADC1.
*   Можно ещё использовать **GPIO\*\*\*\*0, 2, 5, 12, 15**, но с учетом того, что их нельзя подтягивать ни к питанию, ни к земле при старте микроконтроллера.

На все эти выводы можно подключить обработчики событий для отслеживания изменения уровня извне микроконтроллера, об этом будет написано ниже

Хочу обратить ваше внимание только на то, что,[согласно спецификации](https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_en.pdf), выводы GPIO допускают ток аж до 40 mA “высокого” уровня и до 28 mA “низкого” уровня. Это позволяет управлять различными слаботочными устройствами типа светодиодов напрямую, без применения коммутирующих транзисторов, нужно только учитывать напряжение на выводе не более 3.3В.

> Более подробно об выводах микроконтроллера ESP32 вы можете прочитать [в отдельной статье](добавить ссылку на описание GPIO). Там же можно скачать достаточно удобную excel-таблицу для распределения выводов в своем проекте с учетом их особенностей. Если вам не хватает свободных GPIO, вы можете воспользоваться I2C расширителями GPIO, например [PCF8574](pcf8574) или [MCP23017](mcp23017).

## Настройка порта GPIO

Для работы с портами GPIO необходимо подключить пакет “System.Device.Gpio” через Nuget:

`# using System.Device.Gpio;`

Прежде чем начинать работу с GPIO, его нужно настроить (сконфигурировать). Каждый “универсальный” порт можно настроить:

*   **направление**: на вход или выход
*   **слабая подтяжка**(45 КОм) к +3,3В или к “земле”
*   **прерывание**(если необходимо)

Nanoframework предлагает следующий способ конфигурации:

* установить состояние выходных контактов GPIO, 
* прочитать состояние входных контактов GPIO, 
* настроить обработчики для реагирования на события изменения состояния GPIO при внешнем стимуле    

```
    //Иницилизация объекта GpioController для работы с I/O 
    GpioController gpioController = new GpioController();

    //Создание объекта GpioPin, настроенного на выход
    //
    GpioPin outputPin = gpioController.openPin(7, PinMode.Output);

    //Создание объекта GpioPin, настроенного на вход
    GpioPin inputPin = gpioController.openPin(7, PinMode.Input);
```
## Работа с портом как выход

```
    // Изменить состояние выхода - высокий уровень
    outputPin.Write(PinValue.High)

     // Изменить состояние выхода - низкий уровень
    outputPin.Write(PinValue.Low)

    // Изменить состояние выхода на противоположный
    outputPin.Toggle()
```

## Работа с портом как вход 

```
    // Чтение состояния входа
    inputPin.Read();
    
    //Регистрация обработчика события на вход
    inputPin.ValueChanged += UserButton_ValueChanged;

    //Функция обработки события на входе
    void UserButton_ValueChanged(object sender, PinValueChangedEventArgs e){

        //Типы событий, которые могут быть вызваны GPIO. Также используется для передачи полученных типов событий.
        PinEventTypes type = e.ChangeType;

        // Вход на подъеме
        boolean isRising = type ==  PinEventTypes.Rising;

        // Вход на спаде
        boolean isRising = type ==  PinEventTypes.Falling;

        // Номер контакта, вызвавший событие.
        int pin = e.PinNumber;
    }
```
## Работа с портом как вход (IoT style)
```
    //Иницилизация объекта GpioController для работы с I/O 
    GpioController gpioController = new GpioController();

    //Регистрация события у объекта GpioController
    gpioController.RegisterCallbackForPinValueChangedEvent(
                7,
                PinEventTypes.Falling | PinEventTypes.Rising,
                UserButton_ValueChanged);
    // 1. Номер пина
    // 2. Тип срабатывания - по восходящему или нисходящему фронту
    // 3. Функция обработки события

    //Функция обработки события на входе
    void UserButton_ValueChanged(object sender, PinValueChangedEventArgs e){

        //Типы событий, которые могут быть вызваны GPIO. Также используется для передачи полученных типов событий.
        PinEventTypes type = e.ChangeType;

        // Вход на подъеме
        boolean isRising = type ==  PinEventTypes.Rising;

        // Вход на спаде
        boolean isRising = type ==  PinEventTypes.Falling;

        // Номер контакта, вызвавший событие.
        int pin = e.PinNumber;
    }
```

## Работа с портом как с кнопкой

Для работы с портами GPIO необходимо подключить пакет “Ioit.Device.Button” через Nuget:

`using Iot.Device.Button;`
```
    //Иницилизация объекта GpioController для работы с I/O 
    GpioController gpioController = new GpioController();

    //Иницилизация объекта GpioButton для работы в качестве кнопки 
    GpioButton button = new GpioButton(buttonPin: 25, gpio: gpioController);

    //Создание объекта GpioPin, настроенного на выход

    //включено или выключено событие удержания на кнопке.
    button.IsDoublePressEnabled = true;

    //включено или выключено событие двойного нажатия на кнопке.
    button.IsHoldingEnabled = true;

    //Регистрация обработчика события при нажатии на кнопку
    button.ButtonDown += (sender, e) => {};

    //Регистрация обработчика события при отжатии кнопки
    button.ButtonUp += (sender, e) => {};

    //Регистрация обработчика события при нажатию на кнопку
    button.Press += (sender, e) => {};

    //Регистрация обработчика события при двойном нажатии на кнопку
    button.DoublePress += (sender, e) => {};

     //Регистрация обработчика события при удержании нажатия на кнопку
    button.Holding += (sender, e) => {};
```

## Типы PinMode
```
        
        /// Настраивает вывод GPIO в плавающем режиме с высоким импедансом.
        Input,

        /// Настраивает вывод GPIO в режиме высокого импеданса с подтягивающим резистором к земле.
        InputPullDown,

        /// Настраивает вывод GPIO в режиме высокого импеданса с подтягивающим резистором к линии заряда напряжения (VCC).
        InputPullUp,

        /// Настраивает вывод GPIO в режиме сильного драйвера с низким импедансом.
        Output,

        /// Настраивает вывод GPIO в режиме открытого стока.
        OutputOpenDrain,

        /// Настраивает вывод GPIO в режиме открытого стока с резистивной подтяжкой.
        OutputOpenDrainPullUp,

        /// Настраивает вывод GPIO в режиме открытого коллектора.
        OutputOpenSource,

        /// Настраивает вывод GPIO в режиме открытого коллектора с резистивным подтягиванием к земле.
        OutputOpenSourcePullDown
```


### **Полезные ссылки**

1.  [ESP-IDF — GPIO and RTC GPIO.](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/peripherals/gpio.html#gpio-rtc-gpio)
2.  [Пример на GitHub](https://github.com/kotyara12/dzen/tree/master/gpio)
